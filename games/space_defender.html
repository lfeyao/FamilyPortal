<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defender: Ultimate Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            font-family: 'Orbitron', 'Courier New', monospace;
            background: #000;
            overflow: hidden;
            color: white;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(ellipse at center, #0a0033 0%, #000000 100%);
            touch-action: none;
            user-select: none;
        }

        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5px, 5px); }
            20% { transform: translate(5px, -5px); }
            30% { transform: translate(-5px, -5px); }
            40% { transform: translate(5px, 5px); }
            50% { transform: translate(-5px, 5px); }
            60% { transform: translate(5px, -5px); }
            70% { transform: translate(-5px, -5px); }
            80% { transform: translate(5px, 5px); }
            90% { transform: translate(-5px, 5px); }
        }

        .shake {
            animation: screenShake 0.3s;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 1.1em;
        }

        .stat {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(138, 43, 226, 0.2));
            padding: 12px 20px;
            border: 2px solid;
            border-image: linear-gradient(45deg, #00ffff, #ff00ff) 1;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            animation: hudGlow 2s ease-in-out infinite;
        }

        @keyframes hudGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); }
        }

        .health-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: min(500px, 90vw);
            height: 35px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ffff;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ffaa00 25%, #ffff00 50%, #00ff00 100%);
            transition: width 0.3s;
            box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.5);
            position: relative;
        }

        .health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: healthShine 2s linear infinite;
        }

        @keyframes healthShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .powerup-bar {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #ffff00;
            border-radius: 10px;
            min-width: 200px;
            display: none;
            backdrop-filter: blur(10px);
        }

        .powerup-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .powerup-timer {
            color: #ffff00;
            font-weight: bold;
        }

        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 0, 40, 0.95));
            padding: 40px;
            border: 3px solid;
            border-image: linear-gradient(45deg, #00ffff, #ff00ff, #00ffff) 1;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: all;
        }

        .menu h1 {
            font-size: 3.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #00ffff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            font-weight: 900;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .menu .subtitle {
            font-size: 1.3em;
            color: #00ffff;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .menu button {
            display: block;
            width: 100%;
            max-width: 400px;
            margin: 12px auto;
            padding: 16px;
            font-size: 1.2em;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 2px solid #00ffff;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .menu button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .menu button:hover::before {
            left: 100%;
        }

        .menu button:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .difficulty-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }

        .difficulty-option {
            padding: 25px 15px;
            border: 3px solid #666;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(0, 0, 0, 0.5);
        }

        .difficulty-option:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
        }

        .difficulty-option.selected {
            border-width: 4px;
            box-shadow: 0 0 35px rgba(0, 255, 255, 0.8);
        }

        .difficulty-option.easy { border-color: #00ff00; }
        .difficulty-option.easy.selected { background: rgba(0, 255, 0, 0.2); }

        .difficulty-option.normal { border-color: #00ffff; }
        .difficulty-option.normal.selected { background: rgba(0, 255, 255, 0.2); }

        .difficulty-option.hard { border-color: #ffaa00; }
        .difficulty-option.hard.selected { background: rgba(255, 170, 0, 0.2); }

        .difficulty-option.insane { border-color: #ff0000; }
        .difficulty-option.insane.selected { background: rgba(255, 0, 0, 0.2); }

        .difficulty-name {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .difficulty-desc {
            font-size: 0.75em;
            color: #aaa;
            line-height: 1.4;
        }

        .ship-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }

        .ship-option {
            padding: 20px 15px;
            border: 3px solid #666;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(0, 0, 0, 0.5);
        }

        .ship-option:hover {
            border-color: #00ffff;
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
        }

        .ship-option.selected {
            border-color: #00ffff;
            border-width: 4px;
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 35px rgba(0, 255, 255, 0.8);
        }

        .ship-icon {
            font-size: 3.5em;
            margin-bottom: 10px;
        }

        .ship-name {
            font-size: 1em;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .ship-ability {
            font-size: 0.75em;
            color: #aaa;
            line-height: 1.4;
        }

        .controls-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1em;
            color: #00ffff;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .game-over {
            display: none;
        }

        .wave-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4em;
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: none;
            animation: waveAnim 2s forwards;
            pointer-events: none;
        }

        @keyframes waveAnim {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .mode-desc {
            font-size: 0.8em;
            color: #888;
            line-height: 1.6;
        }

        .back-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
        }

        .back-btn:hover {
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 100%) !important;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="hud">
            <div class="stat">‚≠ê <span id="score">0</span></div>
            <div class="stat">üåä Wave <span id="wave">1</span></div>
            <div class="stat" id="killsStat">üíÄ <span id="kills">0</span></div>
            <div class="stat" id="timerStat" style="display: none;">‚è±Ô∏è <span id="survivalTime">3:00</span></div>
        </div>

        <div class="health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%;"></div>
        </div>

        <div class="powerup-bar" id="powerupBar">
            <div style="font-weight: bold; margin-bottom: 10px; color: #ffff00;">üî• ACTIVE POWERUPS</div>
            <div id="powerupList"></div>
        </div>

        <div class="wave-msg" id="waveMsg"></div>

        <div class="controls-hint" id="controlsHint" style="display: none;">
            üéÆ MOVE: Mouse/Touch Drag | SHOOT: Auto üéÆ
        </div>

        <div class="menu" id="mainMenu">
            <h1>SPACE DEFENDER</h1>
            <div class="subtitle">‚ö° ULTIMATE EDITION ‚ö°</div>
            <button onclick="showDifficultySelect()">üöÄ START GAME</button>
        </div>

        <div class="menu" id="difficultyMenu" style="display: none;">
            <h1>SELECT DIFFICULTY</h1>
            <div class="subtitle">Choose your challenge level</div>
            
            <div class="difficulty-selector">
                <div class="difficulty-option easy selected" data-difficulty="easy">
                    <div class="difficulty-name" style="color: #00ff00;">üü¢ EASY</div>
                    <div class="difficulty-desc">Perfect for beginners<br>More HP ‚Ä¢ Slower enemies</div>
                </div>
                <div class="difficulty-option normal" data-difficulty="normal">
                    <div class="difficulty-name" style="color: #00ffff;">üîµ NORMAL</div>
                    <div class="difficulty-desc">Balanced experience<br>Standard difficulty</div>
                </div>
                <div class="difficulty-option hard" data-difficulty="hard">
                    <div class="difficulty-name" style="color: #ffaa00;">üü† HARD</div>
                    <div class="difficulty-desc">Experienced players<br>Fast & tough</div>
                </div>
                <div class="difficulty-option insane" data-difficulty="insane">
                    <div class="difficulty-name" style="color: #ff0000;">üî¥ INSANE</div>
                    <div class="difficulty-desc">EXTREME CHALLENGE<br>Good luck!</div>
                </div>
            </div>

            <button onclick="showShipSelect()">‚ñ∂Ô∏è CONTINUE</button>
            <button class="back-btn" onclick="backToMain()">‚óÄÔ∏è BACK</button>
        </div>

        <div class="menu" id="shipMenu" style="display: none;">
            <h1>CHOOSE YOUR SHIP</h1>
            <div class="subtitle">Each ship has unique weapons!</div>
            
            <div class="ship-selector">
                <div class="ship-option selected" data-ship="fighter">
                    <div class="ship-icon">üöÄ</div>
                    <div class="ship-name">FIGHTER</div>
                    <div class="ship-ability">Cyan Lasers<br>Balanced</div>
                </div>
                <div class="ship-option" data-ship="interceptor">
                    <div class="ship-icon">‚ö°</div>
                    <div class="ship-name">INTERCEPTOR</div>
                    <div class="ship-ability">Yellow Bolts<br>Super Speed</div>
                </div>
                <div class="ship-option" data-ship="tank">
                    <div class="ship-icon">üõ°Ô∏è</div>
                    <div class="ship-name">TANK</div>
                    <div class="ship-ability">Green Plasma<br>High HP</div>
                </div>
                <div class="ship-option" data-ship="sniper">
                    <div class="ship-icon">üéØ</div>
                    <div class="ship-name">SNIPER</div>
                    <div class="ship-ability">Purple Beams<br>Triple Shot</div>
                </div>
                <div class="ship-option" data-ship="gunship">
                    <div class="ship-icon">üí•</div>
                    <div class="ship-name">GUNSHIP</div>
                    <div class="ship-ability">Orange Missiles<br>Rapid Fire</div>
                </div>
            </div>

            <button onclick="showModeSelect()">‚ñ∂Ô∏è CONTINUE</button>
            <button class="back-btn" onclick="backToDifficulty()">‚óÄÔ∏è BACK</button>
        </div>

        <div class="menu" id="modeMenu" style="display: none;">
            <h1>SELECT MODE</h1>
            <div class="subtitle">Choose your game mode!</div>
            <button onclick="startGame('classic')">‚≠ê CLASSIC MODE</button>
            <button onclick="startGame('endless')">‚ôæÔ∏è ENDLESS MODE</button>
            <button onclick="startGame('boss')">üëπ BOSS RUSH</button>
            <button onclick="startGame('survival')">‚è±Ô∏è SURVIVAL (3 MIN)</button>
            <button onclick="startGame('bullet')">üî• BULLET HELL</button>
            <button class="back-btn" onclick="backToShipSelect()">‚óÄÔ∏è BACK</button>
            <div class="mode-desc" style="margin-top: 20px;">
                üéØ Classic: Boss every 5 waves<br>
                ‚ôæÔ∏è Endless: Infinite waves<br>
                üëπ Boss Rush: Only bosses<br>
                ‚è±Ô∏è Survival: Survive 3 minutes<br>
                üî• Bullet Hell: Enemies shoot!
            </div>
        </div>

        <div class="menu game-over" id="gameOver">
            <h1 id="gameOverTitle">GAME OVER</h1>
            <p style="font-size: 2em; margin: 20px 0; color: #00ffff;">Score: <span id="finalScore">0</span></p>
            <p style="font-size: 1.3em; margin: 10px 0;">Wave: <span id="finalWave">0</span> | Kills: <span id="finalKills">0</span></p>
            <button onclick="location.reload()" style="margin-top: 20px;">üîÑ PLAY AGAIN</button>
        </div>
    </div>

    <script>
        'use strict';

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let gameActive = false;
        let gameMode = 'classic';
        let selectedShip = 'fighter';
        let selectedDifficulty = 'easy';
        let score = 0;
        let wave = 1;
        let kills = 0;
        let survivalTimer = 180;

        // Difficulty configurations
        const difficulties = {
            easy: {
                hpMultiplier: 1.5,
                enemySpeed: 0.7,
                enemyCount: 0.7,
                bossHp: 0.6,
                bossSpeed: 0.7,
                shootFrequency: 1.5,
                bulletDamage: 0.6,
                powerupChance: 0.85,
                powerupDuration: 1.3,
                healthRestore: 1.5,
                invulnTime: 1.5
            },
            normal: {
                hpMultiplier: 1.0,
                enemySpeed: 1.0,
                enemyCount: 1.0,
                bossHp: 1.0,
                bossSpeed: 1.0,
                shootFrequency: 1.0,
                bulletDamage: 1.0,
                powerupChance: 0.7,
                powerupDuration: 1.0,
                healthRestore: 1.0,
                invulnTime: 1.0
            },
            hard: {
                hpMultiplier: 0.8,
                enemySpeed: 1.4,
                enemyCount: 1.4,
                bossHp: 1.5,
                bossSpeed: 1.3,
                shootFrequency: 0.7,
                bulletDamage: 1.3,
                powerupChance: 0.5,
                powerupDuration: 0.8,
                healthRestore: 0.8,
                invulnTime: 0.8
            },
            insane: {
                hpMultiplier: 0.6,
                enemySpeed: 2.0,
                enemyCount: 1.8,
                bossHp: 2.0,
                bossSpeed: 1.6,
                shootFrequency: 0.5,
                bulletDamage: 1.8,
                powerupChance: 0.35,
                powerupDuration: 0.6,
                healthRestore: 0.6,
                invulnTime: 0.6
            }
        };

        // Ship base configurations
        const shipBases = {
            fighter: {
                color: '#00ffff',
                bulletColor: '#00ffff',
                bulletWidth: 4,
                bulletHeight: 18,
                baseHealth: 200,
                speed: 8,
                shootRate: 8,
                damage: 1,
                bulletSpeed: 12
            },
            interceptor: {
                color: '#ffff00',
                bulletColor: '#ffff00',
                bulletWidth: 3,
                bulletHeight: 15,
                baseHealth: 150,
                speed: 14,
                shootRate: 6,
                damage: 1,
                bulletSpeed: 16
            },
            tank: {
                color: '#00ff00',
                bulletColor: '#00ff00',
                bulletWidth: 6,
                bulletHeight: 20,
                baseHealth: 300,
                speed: 5,
                shootRate: 12,
                damage: 2,
                bulletSpeed: 10
            },
            sniper: {
                color: '#ff00ff',
                bulletColor: '#ff00ff',
                bulletWidth: 2,
                bulletHeight: 25,
                baseHealth: 180,
                speed: 7,
                shootRate: 10,
                damage: 3,
                bulletSpeed: 18
            },
            gunship: {
                color: '#ff8800',
                bulletColor: '#ff8800',
                bulletWidth: 5,
                bulletHeight: 12,
                baseHealth: 200,
                speed: 7,
                shootRate: 3,
                damage: 1,
                bulletSpeed: 14
            }
        };

        // Player
        const player = {
            x: 0,
            y: 0,
            width: 30,
            height: 30,
            health: 200,
            maxHealth: 200,
            speed: 8,
            shootCooldown: 0,
            shootRate: 8,
            powerups: new Map(),
            invulnerable: 0,
            ship: 'fighter'
        };

        // Arrays
        const bullets = [];
        const enemies = [];
        const particles = [];
        const powerups = [];
        const stars = [];

        // Mouse/touch
        let mouseX = 0;
        let mouseY = 0;

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
        }, { passive: false });

        // Stars
        function initStars() {
            stars.length = 0;
            for (let i = 0; i < 300; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2.5,
                    speed: Math.random() * 3 + 0.5,
                    brightness: Math.random()
                });
            }
        }
        initStars();

        // Difficulty selection
        document.querySelectorAll('.difficulty-option').forEach(option => {
            option.addEventListener('click', function() {
                selectedDifficulty = this.getAttribute('data-difficulty');
                document.querySelectorAll('.difficulty-option').forEach(el => el.classList.remove('selected'));
                this.classList.add('selected');
            });
        });

        // Ship selection
        document.querySelectorAll('.ship-option').forEach(option => {
            option.addEventListener('click', function() {
                selectedShip = this.getAttribute('data-ship');
                document.querySelectorAll('.ship-option').forEach(el => el.classList.remove('selected'));
                this.classList.add('selected');
            });
        });

        function showDifficultySelect() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('difficultyMenu').style.display = 'block';
        }

        function showShipSelect() {
            document.getElementById('difficultyMenu').style.display = 'none';
            document.getElementById('shipMenu').style.display = 'block';
        }

        function showModeSelect() {
            document.getElementById('shipMenu').style.display = 'none';
            document.getElementById('modeMenu').style.display = 'block';
        }

        function backToMain() {
            document.getElementById('difficultyMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';
        }

        function backToDifficulty() {
            document.getElementById('shipMenu').style.display = 'none';
            document.getElementById('difficultyMenu').style.display = 'block';
        }

        function backToShipSelect() {
            document.getElementById('modeMenu').style.display = 'none';
            document.getElementById('shipMenu').style.display = 'block';
        }

        function getDifficultyMultiplier(stat) {
            return difficulties[selectedDifficulty][stat] || 1.0;
        }

        function startGame(mode) {
            gameMode = mode;
            gameActive = true;
            document.getElementById('modeMenu').style.display = 'none';
            document.getElementById('controlsHint').style.display = 'block';
            
            // Setup ship with difficulty
            const shipConfig = shipBases[selectedShip];
            player.ship = selectedShip;
            player.maxHealth = Math.floor(shipConfig.baseHealth * getDifficultyMultiplier('hpMultiplier'));
            player.health = player.maxHealth;
            player.speed = shipConfig.speed;
            player.shootRate = shipConfig.shootRate;
            
            // Reset
            score = 0;
            wave = 1;
            kills = 0;
            survivalTimer = 180;
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            player.invulnerable = Math.floor(120 * getDifficultyMultiplier('invulnTime'));
            mouseX = player.x;
            mouseY = player.y;
            bullets.length = 0;
            enemies.length = 0;
            particles.length = 0;
            powerups.length = 0;
            player.powerups.clear();
            player.shootCooldown = 0;
            
            if (mode === 'survival') {
                document.getElementById('timerStat').style.display = 'block';
                document.getElementById('killsStat').style.display = 'none';
            } else {
                document.getElementById('timerStat').style.display = 'none';
                document.getElementById('killsStat').style.display = 'block';
            }
            
            updateHUD();
            spawnWave();
            gameLoop();
        }

        function spawnWave() {
            const countMult = getDifficultyMultiplier('enemyCount');
            
            if (gameMode === 'boss') {
                showWaveMessage(`üëπ BOSS ${wave}`);
                setTimeout(() => spawnBoss(), 2000);
            } else if (gameMode === 'survival') {
                showWaveMessage(`WAVE ${wave}`);
                const count = Math.max(1, Math.floor((5 + wave * 2) * countMult));
                for (let i = 0; i < count; i++) {
                    setTimeout(() => spawnEnemy(), i * 300);
                }
            } else if (gameMode === 'bullet') {
                showWaveMessage(`üí• WAVE ${wave}`);
                const count = Math.max(1, Math.floor((4 + wave * 2) * countMult));
                for (let i = 0; i < count; i++) {
                    setTimeout(() => spawnShooterEnemy(), i * 400);
                }
            } else if (gameMode === 'endless') {
                showWaveMessage(`WAVE ${wave}`);
                const count = Math.max(1, Math.floor((3 + wave) * countMult));
                for (let i = 0; i < count; i++) {
                    setTimeout(() => spawnEnemy(), i * 500);
                }
            } else {
                if (wave % 5 === 0) {
                    showWaveMessage(`‚ö†Ô∏è BOSS WAVE ${wave}`);
                    setTimeout(() => spawnBoss(), 2000);
                } else {
                    showWaveMessage(`WAVE ${wave}`);
                    const count = Math.max(1, Math.floor((3 + wave) * countMult));
                    for (let i = 0; i < count; i++) {
                        setTimeout(() => spawnEnemy(), i * 500);
                    }
                }
            }
        }

        function spawnEnemy() {
            if (!gameActive) return;
            const w = 30;
            const speedMult = getDifficultyMultiplier('enemySpeed');
            const safeX = Math.max(w, Math.min(canvas.width - w, w + Math.random() * (canvas.width - w * 2)));
            enemies.push({
                x: safeX,
                y: -50,
                width: w,
                height: w,
                speed: 1.5 * speedMult,
                health: 1,
                maxHealth: 1,
                score: 10,
                type: 'normal'
            });
        }

        function spawnShooterEnemy() {
            if (!gameActive) return;
            const w = 30;
            const speedMult = getDifficultyMultiplier('enemySpeed');
            const safeX = Math.max(w, Math.min(canvas.width - w, w + Math.random() * (canvas.width - w * 2)));
            enemies.push({
                x: safeX,
                y: -50,
                width: w,
                height: w,
                speed: 1.2 * speedMult,
                health: 2,
                maxHealth: 2,
                score: 20,
                type: 'shooter',
                shootCooldown: Math.floor(90 * getDifficultyMultiplier('shootFrequency'))
            });
        }

        function spawnBoss() {
            if (!gameActive) return;
            const hpMult = getDifficultyMultiplier('bossHp');
            const speedMult = getDifficultyMultiplier('bossSpeed');
            enemies.push({
                x: canvas.width / 2,
                y: -150,
                width: 120,
                height: 120,
                speed: 0.8 * speedMult,
                health: Math.floor((50 + wave * 15) * hpMult),
                maxHealth: Math.floor((50 + wave * 15) * hpMult),
                score: 1000,
                type: 'boss',
                shootCooldown: 0,
                pattern: 0
            });
        }

        function shootBullet(x, y, vx, vy, isEnemy = false) {
            const shipConfig = shipBases[player.ship];
            const baseDamage = isEnemy ? 1 : shipConfig.damage;
            const finalDamage = player.powerups.has('damage') ? baseDamage * 2 : baseDamage;
            
            bullets.push({
                x, y, vx, vy,
                width: isEnemy ? 4 : shipConfig.bulletWidth,
                height: isEnemy ? 15 : shipConfig.bulletHeight,
                color: isEnemy ? '#ff0000' : shipConfig.bulletColor,
                isEnemy,
                damage: finalDamage
            });
        }

        function spawnPowerup(x, y) {
            if (Math.random() < getDifficultyMultiplier('powerupChance')) {
                const types = ['health', 'shield', 'rapid', 'damage', 'nuke', 'triple', 'magnet'];
                const type = types[Math.floor(Math.random() * types.length)];
                powerups.push({ x, y, type, size: 25, vy: 2 });
            }
        }

        function createExplosion(x, y, count = 30, color = null) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    size: Math.random() * 5 + 2,
                    life: 1,
                    color: color || `hsl(${Math.random() * 60 + 15}, 100%, 50%)`
                });
            }
        }

        function screenShake() {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 300);
        }

        function showWaveMessage(text) {
            const msg = document.getElementById('waveMsg');
            msg.textContent = text;
            msg.style.display = 'block';
            setTimeout(() => { if (msg) msg.style.display = 'none'; }, 2000);
        }

        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('wave').textContent = wave;
            document.getElementById('kills').textContent = kills;
            const healthPercent = Math.max(0, Math.min(100, (player.health / player.maxHealth * 100)));
            document.getElementById('healthFill').style.width = healthPercent + '%';
            
            if (player.powerups.size > 0) {
                document.getElementById('powerupBar').style.display = 'block';
                let html = '';
                const icons = {
                    health: '‚ù§Ô∏è', shield: 'üõ°Ô∏è', rapid: 'üî•', damage: '‚ö°',
                    nuke: 'üí£', triple: 'üéØ', magnet: 'üß≤'
                };
                player.powerups.forEach((time, type) => {
                    const secs = Math.ceil(time / 60);
                    html += `<div class="powerup-item">${icons[type] || 'üíé'} ${type.toUpperCase()} <span class="powerup-timer">${secs}s</span></div>`;
                });
                document.getElementById('powerupList').innerHTML = html;
            } else {
                document.getElementById('powerupBar').style.display = 'none';
            }
        }

        function drawShip() {
            const shipConfig = shipBases[player.ship];
            
            if (Math.random() < 0.6) {
                particles.push({
                    x: player.x + (Math.random() - 0.5) * 20,
                    y: player.y + 15,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 4 + 1,
                    size: Math.random() * 4 + 1,
                    life: 0.6,
                    color: shipConfig.color
                });
            }

            ctx.save();
            ctx.translate(player.x, player.y);
            
            if (player.invulnerable > 0) {
                ctx.globalAlpha = Math.sin(Date.now() / 50) * 0.5 + 0.5;
            }
            
            ctx.shadowBlur = 35;
            ctx.shadowColor = shipConfig.color;
            ctx.fillStyle = shipConfig.color;
            
            if (player.ship === 'fighter') {
                ctx.beginPath();
                ctx.moveTo(0, -22);
                ctx.lineTo(-16, 16);
                ctx.lineTo(0, 11);
                ctx.lineTo(16, 16);
                ctx.closePath();
                ctx.fill();
            } else if (player.ship === 'interceptor') {
                ctx.beginPath();
                ctx.moveTo(0, -24);
                ctx.lineTo(-10, 16);
                ctx.lineTo(0, 12);
                ctx.lineTo(10, 16);
                ctx.closePath();
                ctx.fill();
                ctx.fillRect(-20, 0, 8, 20);
                ctx.fillRect(12, 0, 8, 20);
            } else if (player.ship === 'tank') {
                ctx.fillRect(-20, -15, 40, 30);
                ctx.fillRect(-12, -20, 24, 10);
            } else if (player.ship === 'sniper') {
                ctx.beginPath();
                ctx.moveTo(0, -25);
                ctx.lineTo(-14, 16);
                ctx.lineTo(0, 8);
                ctx.lineTo(14, 16);
                ctx.closePath();
                ctx.fill();
                ctx.fillRect(-3, -30, 6, 15);
            } else if (player.ship === 'gunship') {
                ctx.fillRect(-18, -12, 36, 28);
                ctx.fillRect(-25, -8, 10, 20);
                ctx.fillRect(15, -8, 10, 20);
            }
            
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#ffffff';
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();
            
            if (player.powerups.has('shield')) {
                ctx.strokeStyle = `rgba(255, 255, 0, ${0.6 + Math.sin(Date.now() / 100) * 0.2})`;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 35;
                ctx.shadowColor = '#ffff00';
                ctx.beginPath();
                ctx.arc(0, 0, 32 + Math.sin(Date.now() / 100) * 4, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function gameLoop() {
            if (!gameActive) return;

            ctx.fillStyle = 'rgba(0, 0, 10, 0.25)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars
            stars.forEach(s => {
                s.y += s.speed;
                if (s.y > canvas.height) {
                    s.y = 0;
                    s.x = Math.random() * canvas.width;
                }
                s.brightness += 0.05;
                const alpha = (Math.sin(s.brightness) + 1) / 2;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fillRect(s.x, s.y, s.size, s.size);
            });

            const shipConfig = shipBases[player.ship];

            // Player movement
            const dx = mouseX - player.x;
            const dy = mouseY - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 5) {
                const spd = player.powerups.has('magnet') ? player.speed * 1.3 : player.speed;
                player.x += (dx / dist) * Math.min(spd, dist);
                player.y += (dy / dist) * Math.min(spd, dist);
            }

            player.x = Math.max(25, Math.min(canvas.width - 25, player.x));
            player.y = Math.max(25, Math.min(canvas.height - 25, player.y));

            // Shooting
            player.shootCooldown--;
            const rate = player.powerups.has('rapid') ? Math.max(1, Math.floor(player.shootRate / 2)) : player.shootRate;
            const hasTriple = player.powerups.has('triple') || player.ship === 'sniper';
            const bulletSpd = shipConfig.bulletSpeed;
            
            if (player.shootCooldown <= 0) {
                if (hasTriple) {
                    shootBullet(player.x - 15, player.y - 20, -2, -bulletSpd);
                    shootBullet(player.x, player.y - 20, 0, -bulletSpd);
                    shootBullet(player.x + 15, player.y - 20, 2, -bulletSpd);
                } else {
                    shootBullet(player.x, player.y - 20, 0, -bulletSpd);
                }
                player.shootCooldown = rate;
            }

            drawShip();

            // Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;

                if (b.y < -30 || b.y > canvas.height + 30 || b.x < -10 || b.x > canvas.width + 10) {
                    bullets.splice(i, 1);
                    continue;
                }

                if (!b.isEnemy && Math.random() < 0.5) {
                    particles.push({
                        x: b.x, y: b.y, vx: 0, vy: 1,
                        size: 2, life: 0.4, color: b.color
                    });
                }

                ctx.fillStyle = b.color;
                ctx.shadowBlur = 30;
                ctx.shadowColor = b.color;
                ctx.fillRect(b.x - b.width / 2, b.y - b.height / 2, b.width, b.height);
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.width + 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                
                if (e.type === 'boss') {
                    if (e.y < 100) {
                        e.y += e.speed;
                    } else {
                        e.x += Math.sin(e.pattern) * 4.5;
                        e.pattern += 0.045;
                    }
                    
                    e.x = Math.max(e.width / 2 + 20, Math.min(canvas.width - e.width / 2 - 20, e.x));
                    
                    e.shootCooldown--;
                    const shootMult = getDifficultyMultiplier('shootFrequency');
                    if (e.shootCooldown <= 0) {
                        const hp = e.health / e.maxHealth;
                        if (hp > 0.66) {
                            for (let a = 0; a < Math.PI * 2; a += Math.PI / 4) {
                                shootBullet(e.x, e.y, Math.cos(a) * 3.5, Math.sin(a) * 3.5, true);
                            }
                            e.shootCooldown = Math.floor(85 * shootMult);
                        } else if (hp > 0.33) {
                            const pa = Math.atan2(player.y - e.y, player.x - e.x);
                            for (let j = -2; j <= 2; j++) {
                                shootBullet(e.x, e.y, Math.cos(pa + j * 0.3) * 5.5, Math.sin(pa + j * 0.3) * 5.5, true);
                            }
                            e.shootCooldown = Math.floor(55 * shootMult);
                        } else {
                            for (let a = 0; a < Math.PI * 2; a += Math.PI / 6) {
                                shootBullet(e.x, e.y, Math.cos(a) * 4.5, Math.sin(a) * 4.5, true);
                            }
                            const pa = Math.atan2(player.y - e.y, player.x - e.x);
                            shootBullet(e.x, e.y, Math.cos(pa) * 7, Math.sin(pa) * 7, true);
                            e.shootCooldown = Math.floor(40 * shootMult);
                        }
                    }
                    
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.pattern * 0.6);
                    
                    ctx.shadowBlur = 50;
                    ctx.shadowColor = '#ff00ff';
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(-e.width / 2, -e.height / 2, e.width, e.height);
                    
                    ctx.fillStyle = '#ff0088';
                    ctx.fillRect(-e.width / 3, -e.height / 3, e.width * 2 / 3, e.height * 2 / 3);
                    
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#00ffff';
                    ctx.fillRect(-32, -22, 16, 16);
                    ctx.fillRect(16, -22, 16, 16);
                    
                    ctx.restore();
                    
                    const bw = Math.min(420, canvas.width - 40), bh = 22;
                    const bx = canvas.width / 2 - bw / 2, by = 65;
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(100, 0, 0, 0.7)';
                    ctx.fillRect(bx, by, bw, bh);
                    ctx.fillStyle = '#ff00ff';
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff00ff';
                    ctx.fillRect(bx, by, bw * Math.max(0, e.health / e.maxHealth), bh);
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 15px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText(`BOSS HP: ${Math.ceil(Math.max(0, e.health))}`, canvas.width / 2, by + 16);
                    
                } else {
                    e.y += e.speed;
                    e.x = Math.max(e.width / 2, Math.min(canvas.width - e.width / 2, e.x));

                    if (e.type === 'shooter' && e.y > 60 && e.y < canvas.height - 100) {
                        e.shootCooldown--;
                        if (e.shootCooldown <= 0) {
                            const pa = Math.atan2(player.y - e.y, player.x - e.x);
                            shootBullet(e.x, e.y, Math.cos(pa) * 4.5, Math.sin(pa) * 4.5, true);
                            e.shootCooldown = Math.floor(90 * getDifficultyMultiplier('shootFrequency'));
                        }
                    }

                    const col = e.type === 'shooter' ? 'rgba(255, 100, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = col;
                    ctx.fillRect(e.x - e.width / 2, e.y - e.height / 2 - 12, e.width, e.height);
                    
                    const mainCol = e.type === 'shooter' ? '#ff6600' : '#ff0000';
                    ctx.fillStyle = mainCol;
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = mainCol;
                    ctx.fillRect(e.x - e.width / 2, e.y - e.height / 2, e.width, e.height);
                    
                    if (e.type === 'shooter') {
                        ctx.fillStyle = '#ffff00';
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Enemy escape check
                if (e.y > canvas.height + 60) {
                    player.health = 0;
                    createExplosion(player.x, player.y, 50, shipConfig.color);
                    screenShake();
                    endGame();
                    return;
                }

                // Enemy collision with player
                const pd = Math.sqrt(Math.pow(e.x - player.x, 2) + Math.pow(e.y - player.y, 2));
                const cd = e.type === 'boss' ? e.width / 2 + 32 : e.width / 2 + 22;
                
                if (pd < cd) {
                    if (!player.powerups.has('shield') && player.invulnerable <= 0) {
                        player.health = 0;
                        createExplosion(player.x, player.y, 50);
                        createExplosion(e.x, e.y, 35);
                        screenShake();
                        endGame();
                        return;
                    } else if (player.powerups.has('shield') && player.invulnerable <= 0) {
                        score += e.score;
                        kills++;
                        createExplosion(e.x, e.y, e.type === 'boss' ? 120 : 35);
                        if (e.type === 'boss') {
                            screenShake();
                            showWaveMessage('üèÜ BOSS DEFEATED');
                        }
                        enemies.splice(i, 1);
                    }
                }
            }

            if (player.invulnerable > 0) player.invulnerable--;

            // Bullet collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                
                if (b.isEnemy) {
                    if (Math.abs(b.x - player.x) < 22 && Math.abs(b.y - player.y) < 22) {
                        if (!player.powerups.has('shield') && player.invulnerable <= 0) {
                            player.health -= Math.floor(5 * getDifficultyMultiplier('bulletDamage'));
                            createExplosion(b.x, b.y, 12, '#ff0000');
                            updateHUD();
                            if (player.health <= 0) {
                                endGame();
                                return;
                            }
                        }
                        bullets.splice(i, 1);
                    }
                } else {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const e = enemies[j];
                        if (Math.abs(b.x - e.x) < e.width / 2 && Math.abs(b.y - e.y) < e.height / 2) {
                            e.health -= b.damage;
                            createExplosion(b.x, b.y, 8, b.color);
                            bullets.splice(i, 1);
                            
                            if (e.health <= 0) {
                                score += e.score;
                                kills++;
                                createExplosion(e.x, e.y, e.type === 'boss' ? 120 : 30);
                                spawnPowerup(e.x, e.y);
                                
                                if (e.type === 'boss') {
                                    screenShake();
                                    showWaveMessage('üèÜ BOSS DEFEATED');
                                }
                                
                                enemies.splice(j, 1);
                                
                                if (enemies.length === 0 && gameActive) {
                                    wave++;
                                    setTimeout(() => { if (gameActive) spawnWave(); }, 2000);
                                }
                            }
                            break;
                        }
                    }
                }
            }

            // Powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                p.y += p.vy;

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(Date.now() / 400);
                const colors = {
                    health: '#ff0000', shield: '#ffff00', rapid: '#ff8800',
                    damage: '#00ff00', nuke: '#ff00ff', triple: '#00ffff',
                    magnet: '#8800ff'
                };
                ctx.fillStyle = colors[p.type] || '#ffffff';
                ctx.shadowBlur = 28;
                ctx.shadowColor = colors[p.type] || '#ffffff';
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                ctx.restore();

                const magnetRange = player.powerups.has('magnet') ? 150 : 35;
                if (Math.abs(p.x - player.x) < magnetRange && Math.abs(p.y - player.y) < magnetRange) {
                    if (player.powerups.has('magnet')) {
                        const dx = player.x - p.x;
                        const dy = player.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 30) {
                            p.x += (dx / dist) * 5;
                            p.y += (dy / dist) * 5;
                        }
                    }
                    
                    if (Math.abs(p.x - player.x) < 35 && Math.abs(p.y - player.y) < 35) {
                        if (p.type === 'health') {
                            const healAmount = Math.floor(60 * getDifficultyMultiplier('healthRestore'));
                            player.health = Math.min(player.maxHealth, player.health + healAmount);
                        } else if (p.type === 'nuke') {
                            enemies.forEach(e => {
                                score += e.score;
                                kills++;
                                createExplosion(e.x, e.y, 40);
                            });
                            enemies.length = 0;
                            screenShake();
                            showWaveMessage('üí• NUKE! üí•');
                            if (enemies.length === 0 && gameActive && gameMode !== 'survival') {
                                wave++;
                                setTimeout(() => { if (gameActive) spawnWave(); }, 2000);
                            }
                        } else {
                            const duration = Math.floor(600 * getDifficultyMultiplier('powerupDuration'));
                            player.powerups.set(p.type, duration);
                        }
                        powerups.splice(i, 1);
                        createExplosion(p.x, p.y, 18, colors[p.type] || '#ffffff');
                    }
                }

                if (p.y > canvas.height + 20) {
                    powerups.splice(i, 1);
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Powerup timers
            player.powerups.forEach((time, type) => {
                const newTime = time - 1;
                if (newTime <= 0) {
                    player.powerups.delete(type);
                } else {
                    player.powerups.set(type, newTime);
                }
            });

            // Survival mode
            if (gameMode === 'survival' && gameActive) {
                survivalTimer--;
                const m = Math.floor(survivalTimer / 60);
                const s = survivalTimer % 60;
                document.getElementById('survivalTime').textContent = `${m}:${s.toString().padStart(2, '0')}`;
                
                if (survivalTimer <= 0) {
                    gameActive = false;
                    document.getElementById('finalScore').textContent = score;
                    document.getElementById('finalWave').textContent = wave;
                    document.getElementById('finalKills').textContent = kills;
                    document.getElementById('gameOverTitle').textContent = 'üèÜ VICTORY! üèÜ';
                    document.getElementById('gameOver').style.display = 'block';
                    document.getElementById('controlsHint').style.display = 'none';
                    return;
                }
            }

            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            if (!gameActive) return;
            gameActive = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalWave').textContent = wave;
            document.getElementById('finalKills').textContent = kills;
            document.getElementById('gameOverTitle').textContent = 'üíÄ GAME OVER üíÄ';
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('controlsHint').style.display = 'none';
        }

        function backgroundAnimation() {
            if (!gameActive) {
                ctx.fillStyle = 'rgba(0, 0, 10, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                stars.forEach(s => {
                    s.y += s.speed;
                    if (s.y > canvas.height) {
                        s.y = 0;
                        s.x = Math.random() * canvas.width;
                    }
                    ctx.fillStyle = 'white';
                    ctx.fillRect(s.x, s.y, s.size, s.size);
                });
            }
            requestAnimationFrame(backgroundAnimation);
        }

        backgroundAnimation();
    </script>
</body>
</html>
